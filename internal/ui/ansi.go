package ui

import (
	"regexp"
	"strings"

	"abacus/internal/ui/theme"
)

var ansiRegexp = regexp.MustCompile(`\x1b\[[0-9;]*m`)

func stripANSI(s string) string {
	return ansiRegexp.ReplaceAllString(s, "")
}

// fillBackground replaces ANSI reset codes with sequences that preserve the theme background.
// This ensures all whitespace between styled segments has the correct background color.
func fillBackground(s string) string {
	if s == "" {
		return s
	}

	// Get the background color escape sequence from the theme
	bgSeq := theme.Current().BackgroundANSI()
	if bgSeq == "" {
		return s
	}

	// Replace common reset sequences so the theme background persists
	// Add background reset for whitespace runs generated by lipgloss margins/padding
	replacements := []struct {
		old string
		new string
	}{
		{"\x1b[0K", bgSeq},
		{"\x1b[0J", bgSeq},
		{"\x1b[39;49m", "\x1b[39m" + bgSeq},
		{"\x1b[49m", bgSeq},
		{"\x1b[0m", "\x1b[0m" + bgSeq},
		{"\x1b[m", "\x1b[m" + bgSeq},
	}
	for _, repl := range replacements {
		s = strings.ReplaceAll(s, repl.old, repl.new)
	}

	// Ensure each line begins with the background color so plain text lines
	// don't reveal the terminal default background between styled spans.
	if !strings.HasPrefix(s, bgSeq) {
		s = bgSeq + s
	}
	s = strings.ReplaceAll(s, "\n", "\n"+bgSeq)

	return s
}

// fillSecondaryBackground ensures secondary-surface whitespace (e.g., overlays) use the secondary background color.
func fillSecondaryBackground(s string) string {
	if s == "" {
		return s
	}

	bgSeq := theme.Current().BackgroundSecondaryANSI()
	if bgSeq == "" {
		return s
	}

	replacements := []struct {
		old string
		new string
	}{
		{"\x1b[0K", bgSeq},
		{"\x1b[0J", bgSeq},
		{"\x1b[39;49m", "\x1b[39m" + bgSeq},
		{"\x1b[49m", bgSeq},
		{"\x1b[0m", "\x1b[0m" + bgSeq},
		{"\x1b[m", "\x1b[m" + bgSeq},
	}
	for _, repl := range replacements {
		s = strings.ReplaceAll(s, repl.old, repl.new)
	}

	if !strings.HasPrefix(s, bgSeq) {
		s = bgSeq + s
	}
	s = strings.ReplaceAll(s, "\n", "\n"+bgSeq)
	return s
}

// applyDimmer inserts ANSI dim sequences throughout the string so nested content remains dim.
func applyDimmer(s string) string {
	if s == "" {
		return s
	}

	const dimSeq = "\x1b[2m"
	replacements := []struct {
		old string
		new string
	}{
		{"\x1b[0m", "\x1b[0m" + dimSeq},
		{"\x1b[m", "\x1b[m" + dimSeq},
		{"\x1b[22m", "\x1b[22m" + dimSeq},
	}
	for _, repl := range replacements {
		s = strings.ReplaceAll(s, repl.old, repl.new)
	}

	if !strings.HasPrefix(s, dimSeq) {
		s = dimSeq + s
	}
	s = strings.ReplaceAll(s, "\n", "\n"+dimSeq)
	return s
}
