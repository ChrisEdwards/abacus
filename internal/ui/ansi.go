package ui

import (
	"regexp"
	"strings"

	"abacus/internal/ui/theme"
)

var ansiRegexp = regexp.MustCompile(`\x1b\[[0-9;]*m`)

func stripANSI(s string) string {
	return ansiRegexp.ReplaceAllString(s, "")
}

// fillBackground replaces ANSI reset codes with sequences that preserve the theme background.
// This ensures all whitespace between styled segments has the correct background color.
func fillBackground(s string) string {
	if s == "" {
		return s
	}

	// Get the background color escape sequence from the theme
	bgSeq := theme.Current().BackgroundANSI()
	if bgSeq == "" {
		return s
	}

	// Replace common reset sequences so the theme background persists
	// Add background reset for whitespace runs generated by lipgloss margins/padding
	replacements := []struct {
		old string
		new string
	}{
		{"\x1b[0K", bgSeq},
		{"\x1b[0J", bgSeq},
		{"\x1b[39;49m", "\x1b[39m" + bgSeq},
		{"\x1b[49m", bgSeq},
		{"\x1b[0m", "\x1b[0m" + bgSeq},
		{"\x1b[m", "\x1b[m" + bgSeq},
	}
	for _, repl := range replacements {
		s = strings.ReplaceAll(s, repl.old, repl.new)
	}

	// Ensure each line begins with the background color so plain text lines
	// don't reveal the terminal default background between styled spans.
	if !strings.HasPrefix(s, bgSeq) {
		s = bgSeq + s
	}
	s = strings.ReplaceAll(s, "\n", "\n"+bgSeq)

	return s
}

// applyDimmer inserts ANSI dim sequences throughout the string so nested content remains dim.
func applyDimmer(s string) string {
	if s == "" {
		return s
	}

	const dimSeq = "\x1b[2m"
	s = ansiRegexp.ReplaceAllStringFunc(s, func(seq string) string {
		if shouldReapplyDim(seq) {
			return seq + dimSeq
		}
		return seq
	})

	if !strings.HasPrefix(s, dimSeq) {
		s = dimSeq + s
	}
	s = strings.ReplaceAll(s, "\n", "\n"+dimSeq)
	return s
}

func shouldReapplyDim(seq string) bool {
	if !strings.HasPrefix(seq, "\x1b[") || !strings.HasSuffix(seq, "m") {
		return false
	}
	body := strings.TrimSuffix(strings.TrimPrefix(seq, "\x1b["), "m")
	if body == "" {
		return true
	}
	parts := strings.Split(body, ";")
	for i := 0; i < len(parts); i++ {
		part := parts[i]
		switch part {
		case "":
			continue
		case "0", "1", "22":
			return true
		case "38", "48":
			i++
			if i >= len(parts) {
				break
			}
			mode := parts[i]
			var skip int
			switch mode {
			case "5":
				skip = 1
			case "2":
				skip = 3
			}
			remaining := len(parts) - (i + 1)
			if skip > remaining {
				i = len(parts) - 1
			} else {
				i += skip
			}
		}
	}
	return false
}
